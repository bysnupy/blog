# Title: ビルド・デプロイの安定的な処理時間の維持 on OpenShift

Red HatのDaein(デイン)です。OpenShift環境でビルド及デプロイの性能劣化を抑えるためにどうすればいいか考えて見たいと思います。
OpenShiftでは次の通りソースコードをビルドして新しいイメージを作成し、そのイメージを用いて新しいPodをデプロイしています。

- 全体プロセスをシンプルに表現した図は次の通りになります。
![build_deploy_process](https://github.com/bysnupy/blog/blob/master/kubernetes/k8s__build_deploy_resources.png)

ビルドとデプロイ時間に影響する要素としては次のものが考えられます。

処理時間|担当先
-|-
Podのスケジュールから作成までの時間|OpenShift(Kubernetes)
ビルドしたイメージをPUSH及PULLする時間|Image Registry
build Podが稼働されて実際にアプリケーションをビルドする処理時間|アプリケーションのビルド要件に依存
デプロイされたアプリケーションのPodが起動完了するまでの時間|アプリケーションの稼働要件に依存

順番にどのような影響と対応方法があるか見てみましょう。

## Kubernetesでの処理時間
buildConfigやdeploymentConfigによるOpenShift(Kubernetes)側の処理は主にPodのスケジュールからPod(コンテナ)の生成までになります。
実は内部・外部Image RegistryへのPUSH・PULL作業も含まれますが、次のセクションで述べますのでこちらではKubernetesのみ見てみましょう。

結論から言えばビルド・デプロイが遅くなっているものの、処理が成功する場合はこちらの不具合ではない可能性が高いと思います。
通常この段階で問題が発生するとPodのスケジュールやPodの生成が失敗することを意味して作業が始まらない不具合に該当するためです。
リソース不足による影響が考えられますが、設置要件に合う十分なリソースが提供できるホストにMaster API/Controllerが負荷分散できる冗長構成、
かつ高速diskでetcdが構成されている場合はリソース問題の可能性は低いと思います。
他に設定としてはKubeletで安定的にPodが管理・制御できるように"kube-reserved"及び"system-reserved"を設定する方法があると思います。（OpenShift4ではデフォルトで設定されています。）

```yaml
kubeletArguments:
  kube-reserved:
    - "cpu=200m,memory=512Mi"
  system-reserved:
    - "cpu=200m,memory=512Mi"
```

## Image Registryの処理性能
ビルドされたイメージの保存（PUSH）とデプロイする時に必要なイメージをダウン（PULL）する作業は
構成環境のネットワークの帯域や転送速度とRegistryでイメージを保存しているdisk性能に左右されると言って過言ではないと思います。
ImagePullPolicyで無駄なイメージプールがある程度回避できると思いますが、
楽観的な状態ではなく考えられる最大並行実行されるビルド及びデプロイの数から逆算して
PULL・PUSHされるイメージの最大数とそのサイズが耐えられるネットワークとdisk性能が提供できるか先に検証することをお勧めします。

## アプリケーションのビルド要件
ビルドPodが作成されたらビルドプロセスの制御はアプリケーション側に渡されます。
そのため、OpenShiftではビルドPodの稼働・停止は検知できますが、詳細はビルド結果は各ビルドのログを確認する必要があります。
例えば、Javaやnodejsの場合はビルドする時、ソースはSCM(gitなど)から、ビルド時に必要なライブラリやパッケージはmavenやnpmを利用して
ダウンロードしてビルドを実施するため、開発で必要されるリソースが増えたり、参照先のレポジトリの負荷状況に影響を受ける可能性があります。
上記意外に他のプログラム言語のビルド要件で依存される外部リソース・サービスがある場合には同じく依存先の状況に影響を受ける可能性があります。
設定としては、buildConfigの"resources"で十分なリソースをビルドPodに提供する方法が考えられます。
早かったビルドが何も変更されていないのに時間が経って遅くなるパタンはリソース競合が発生し始めた症状としても考えられますのでテストで検証した十分なリソースを予め設定しておくことをお勧めします。

```yaml
apiVersion: "v1"
kind: "BuildConfig"
metadata:
  name: "sample-build"
spec:
  resources:
    limits:
      cpu: "500m" 
      memory: "256Mi"
```

## アプリケーションのデプロイ要件
ビルドPodと同じくアプリケーションのPodが稼働するとアプリケーションの初期化が独自に実施されますので全ての制御はアプリケーションプロセスに渡されます。
例えば、単純にプロセスが稼働することで完結するアプリケーションがあればDBコネクションプールの初期化や
KVSから初期化に必要なデータを取得するなど外部のサービス・データに依存しているアプリケーションもあります。
後者の場合は外部サービスから必要なデータが取得できなかったり、遅かったりすると待機されてデプロイを遅延させる原因になる可能性が高いと思います。
ビルドPodと同じくアプリケーションPodにも当然十分なリソースを設定することで予期せぬリソース不足による性能劣化を抑えられますので検証した十分なリソースを割り当てましょう。

```yaml
apiVersion: apps.openshift.io/v1
kind: DeploymentConfig
spec:
  template:
    spec:
      containers:
      - image: test-image
        name: container1
        resources:
          requests:
            cpu: 100m 
            memory: 200Mi 
          limits:
            cpu: 200m 
            memory: 400Mi
```

## まとめ
この記事ではビルド・デプロイが安定的に実施されるため、どのようなところをチェックすればいいか見てみました。
性能問題はいつどのような影響で発生するか予想が難しいし、直ぐリソースが増強できない環境の場合は復旧に時間が掛かりますので
事前に性能テストを実施してで構築環境の限界を確認してそれに合わせて適切な設定や運営を考えるべきだと思います。
個人的には細かいチューニングで実現した性能はその条件が少しでも離れたら直ぐその効果を失ってしまうと思いますので常に十分なリソースが提供できるようにする方法を推奨します。
